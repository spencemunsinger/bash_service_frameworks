#!/bin/bash

set -euo pipefail

function parseEventToArgs() {
  local event="$1"
  local args=$(echo "$event" | jq -r '.args')
  echo "$args"
}

function handler () {
  local bashargs="$1"
  # Split the arguments string into an array
  IFS=' ' read -r -a args_array <<< "$bashargs"
  # Pass the arguments array to the _main.sh script
  local RESPONSE
  #RESPONSE=$(/var/task/_main.sh "${args_array[@]}")
  RESPONSE=$(/var/task/main.sh "${args_array[@]}")
  printf "%s" "$RESPONSE"
}

_HANDLER="handler"

# Check if running in AWS Lambda
if [ -n "${AWS_LAMBDA_RUNTIME_API:-}" ]; then
  # Processing in AWS Lambda
  while true; do
    HEADERS="$(mktemp)"
    echo "headers: ${HEADERS}"
    # Get an event. The HTTP request will block until one is received
    EVENT_DATA=$(curl -sS -LD "${HEADERS}" "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/next")
    echo "event: ${EVENT_DATA}"
    # Extract request ID by scraping response headers received above
    REQUEST_ID=$(grep -Fi Lambda-Runtime-Aws-Request-Id "${HEADERS}" | tr -d '[:space:]' | cut -d: -f2)
    echo "request: ${REQUEST_ID}"
    echo "handler: ${_HANDLER}"
    bashargs=$(parseEventToArgs "$EVENT_DATA")
    # Run the handler function from the script
    RESPONSE="$(${_HANDLER} "$bashargs")"

    echo "response: ${RESPONSE}"

    # Send the response
    echo "url: http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/${REQUEST_ID}/response"
    curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/${REQUEST_ID}/response" -d "${RESPONSE}"
  done
else
  # Not running in AWS Lambda, execute /var/task/main.sh with args passed to Docker
  /var/task/main.sh "$@"
fi
